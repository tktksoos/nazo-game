<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NOVA STRIKE ONLINE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
  :root {
    --cyan: #00f5ff;
    --magenta: #ff0099;
    --yellow: #ffee00;
    --green: #00ff88;
    --dark: #020814;
    --grid: rgba(0,245,255,0.04);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: var(--dark);
    color: #fff;
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    user-select: none;
  }
  #app { width:100vw; height:100vh; position:relative; }
  #app::before {
    content:'';
    position:fixed; inset:0;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events:none; z-index:0;
  }

  /* ===== SCREENS ===== */
  .screen {
    position:absolute; inset:0;
    display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    gap:24px; z-index:10;
    background: rgba(2,8,20,0.95);
  }
  .screen.hidden { display:none; }

  .game-title {
    font-family:'Orbitron',sans-serif;
    font-size:clamp(32px,7vw,72px);
    font-weight:900; letter-spacing:0.15em;
    color:var(--cyan);
    text-shadow: 0 0 20px var(--cyan), 0 0 60px rgba(0,245,255,0.4);
    animation: pulse 2s ease-in-out infinite;
  }
  .title-sub {
    font-size:12px; letter-spacing:0.4em;
    color:var(--magenta);
    text-shadow: 0 0 10px var(--magenta);
  }
  @keyframes pulse {
    0%,100%{text-shadow:0 0 20px var(--cyan),0 0 60px rgba(0,245,255,0.3);}
    50%{text-shadow:0 0 40px var(--cyan),0 0 100px rgba(0,245,255,0.6);}
  }

  .btn {
    font-family:'Orbitron',sans-serif;
    font-size:14px; letter-spacing:0.2em;
    padding:14px 40px;
    background:transparent;
    border:2px solid var(--cyan);
    color:var(--cyan); cursor:pointer;
    text-transform:uppercase;
    position:relative; overflow:hidden;
    transition:color 0.3s;
  }
  .btn::before {
    content:''; position:absolute; inset:0;
    background:var(--cyan);
    transform:scaleX(0); transform-origin:left;
    transition:transform 0.3s; z-index:-1;
  }
  .btn:hover { color:var(--dark); }
  .btn:hover::before { transform:scaleX(1); }
  .btn.magenta { border-color:var(--magenta); color:var(--magenta); }
  .btn.magenta::before { background:var(--magenta); }
  .btn.magenta:hover { color:var(--dark); }
  .btn.disabled { opacity:0.4; pointer-events:none; }

  .input-field {
    background:rgba(0,245,255,0.05);
    border:1px solid rgba(0,245,255,0.3);
    color:var(--cyan); font-family:'Share Tech Mono',monospace;
    font-size:16px; padding:12px 20px;
    outline:none; text-align:center;
    letter-spacing:0.2em; width:260px;
  }
  .input-field::placeholder { color:rgba(0,245,255,0.3); }

  .status-msg {
    font-size:12px; letter-spacing:0.2em;
    color:rgba(255,255,255,0.5);
    min-height:18px;
  }
  .status-msg.ok { color:var(--green); text-shadow:0 0 10px var(--green); }
  .status-msg.err { color:var(--magenta); }
  .status-msg.wait { color:var(--yellow); animation:blink 1s infinite; }
  @keyframes blink { 0%,100%{opacity:1;} 50%{opacity:0.3;} }

  /* Lobby */
  .room-code-display {
    font-family:'Orbitron',sans-serif;
    font-size:36px; font-weight:900;
    color:var(--yellow);
    text-shadow:0 0 20px var(--yellow);
    letter-spacing:0.4em;
    border:2px solid rgba(255,238,0,0.3);
    padding:16px 32px;
    background:rgba(255,238,0,0.05);
  }

  .player-slots {
    display:flex; gap:20px;
  }
  .slot {
    width:140px; height:80px;
    border:1px solid rgba(255,255,255,0.1);
    display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    gap:6px; padding:10px;
    background:rgba(255,255,255,0.02);
  }
  .slot-name { font-size:13px; }
  .slot-dot {
    width:8px; height:8px; border-radius:50%;
    background:rgba(255,255,255,0.2);
  }
  .slot-dot.active { background:var(--green); box-shadow:0 0 8px var(--green); }
  .slot.p1 .slot-name { color:var(--cyan); }
  .slot.p2 .slot-name { color:var(--magenta); }

  /* ===== HUD ===== */
  #hud {
    position:fixed; top:0; left:0; right:0;
    padding:10px 20px;
    display:none;
    justify-content:space-between; align-items:center;
    z-index:5;
    background:linear-gradient(180deg,rgba(2,8,20,0.95) 0%,transparent 100%);
  }
  .phud { display:flex; flex-direction:column; gap:4px; min-width:160px; }
  .hud-label { font-size:9px; letter-spacing:0.3em; opacity:0.5; }
  .hbar-wrap { display:flex; align-items:center; gap:6px; }
  .hbar { height:6px; width:110px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.15); overflow:hidden; }
  .hfill { height:100%; transition:width 0.15s; }
  .hfill.p1 { background:linear-gradient(90deg,var(--cyan),#00aaff); box-shadow:0 0 6px var(--cyan); }
  .hfill.p2 { background:linear-gradient(90deg,var(--magenta),#ff6600); box-shadow:0 0 6px var(--magenta); }
  .hnum { font-size:10px; }
  .hud-center { text-align:center; }
  .hud-score { font-family:'Orbitron',sans-serif; font-size:22px; color:var(--yellow); text-shadow:0 0 12px var(--yellow); }
  .hud-wave { font-family:'Orbitron',sans-serif; font-size:11px; color:var(--cyan); letter-spacing:0.2em; }
  .ping-display { font-size:9px; color:rgba(255,255,255,0.3); margin-top:2px; }

  /* Wave announce */
  #waveAnn {
    position:fixed; top:50%; left:50%;
    transform:translate(-50%,-50%);
    font-family:'Orbitron',sans-serif;
    font-size:52px; font-weight:900;
    color:var(--cyan); text-shadow:0 0 40px var(--cyan);
    z-index:15; pointer-events:none;
    opacity:0; transition:opacity 0.4s;
  }
  #waveAnn.show { opacity:1; }

  /* Game Over */
  #gameOver {
    display:none; position:fixed; inset:0;
    background:rgba(2,8,20,0.92);
    z-index:20; flex-direction:column;
    align-items:center; justify-content:center; gap:16px;
  }
  #gameOver.show { display:flex; }
  .go-title {
    font-family:'Orbitron',sans-serif;
    font-size:clamp(36px,8vw,72px); font-weight:900;
    color:var(--magenta); text-shadow:0 0 30px var(--magenta);
    animation:glitch 0.4s infinite;
  }
  @keyframes glitch {
    0%,100%{transform:translate(0);}
    20%{transform:translate(-3px,1px);}
    60%{transform:translate(3px,-1px);}
  }
  .go-stats { font-size:13px; color:rgba(255,255,255,0.5); text-align:center; line-height:2; }
  .go-stats span { color:var(--cyan); }

  /* Ping dot */
  #pingDot {
    width:6px; height:6px; border-radius:50%;
    display:inline-block; margin-right:4px;
    background:var(--green);
  }
</style>
</head>
<body>
<div id="app">

  <!-- Title Screen -->
  <div class="screen" id="screenTitle">
    <div class="game-title">NOVA STRIKE</div>
    <div class="title-sub">ONLINE CO-OP SHOOTER</div>
    <input class="input-field" id="nameInput" placeholder="コールサイン入力" maxlength="12">
    <div style="display:flex;gap:12px">
      <button class="btn" onclick="showCreate()">ルーム作成</button>
      <button class="btn magenta" onclick="showJoin()">ルーム参加</button>
    </div>
    <div class="status-msg" id="titleStatus"></div>
    <div style="font-size:10px;color:rgba(255,255,255,0.3);margin-top:10px;text-align:center;line-height:1.8">
      WASD/矢印：移動　マウス：照準　クリック/SPACE：射撃
    </div>
  </div>

  <!-- Join Screen -->
  <div class="screen hidden" id="screenJoin">
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;color:var(--magenta);letter-spacing:0.2em">ROOM JOIN</div>
    <input class="input-field" id="roomCodeInput" placeholder="ルームコード (4桁)" maxlength="4"
      style="text-transform:uppercase;font-size:24px;letter-spacing:0.5em">
    <div style="display:flex;gap:12px">
      <button class="btn magenta" onclick="joinRoom()">参加</button>
      <button class="btn" onclick="showTitle()">戻る</button>
    </div>
    <div class="status-msg" id="joinStatus"></div>
  </div>

  <!-- Lobby Screen -->
  <div class="screen hidden" id="screenLobby">
    <div style="font-family:'Orbitron',sans-serif;font-size:14px;color:rgba(255,255,255,0.4);letter-spacing:0.3em">ROOM CODE</div>
    <div class="room-code-display" id="lobbyCode">----</div>
    <div style="font-size:11px;color:rgba(255,255,255,0.4)">友達にこのコードを教えてください</div>
    <div class="player-slots">
      <div class="slot p1">
        <div class="slot-dot active" id="slot1dot"></div>
        <div class="slot-name" id="slot1name">---</div>
        <div style="font-size:9px;color:rgba(255,255,255,0.3)">PLAYER 1 (HOST)</div>
      </div>
      <div class="slot p2">
        <div class="slot-dot" id="slot2dot"></div>
        <div class="slot-name" id="slot2name">待機中...</div>
        <div style="font-size:9px;color:rgba(255,255,255,0.3)">PLAYER 2</div>
      </div>
    </div>
    <button class="btn disabled" id="startBtn" onclick="hostStartGame()">ゲーム開始</button>
    <div class="status-msg wait" id="lobbyStatus">プレイヤー2を待っています...</div>
  </div>

  <!-- HUD -->
  <div id="hud">
    <div class="phud">
      <div class="hud-label">YOU (<span id="p1label" style="color:var(--cyan)">P1</span>)</div>
      <div class="hbar-wrap">
        <div class="hbar"><div class="hfill p1" id="p1hfill"></div></div>
        <span class="hnum" id="p1hnum" style="color:var(--cyan)">100</span>
      </div>
    </div>
    <div class="hud-center">
      <div class="hud-score" id="scoreDisp">000000</div>
      <div class="hud-wave">WAVE <span id="waveDisp">1</span></div>
      <div class="ping-display"><span id="pingDot"></span><span id="pingVal">--</span>ms</div>
    </div>
    <div class="phud" style="align-items:flex-end">
      <div class="hud-label"><span id="p2label" style="color:var(--magenta)">P2</span></div>
      <div class="hbar-wrap">
        <span class="hnum" id="p2hnum" style="color:var(--magenta)">100</span>
        <div class="hbar"><div class="hfill p2" id="p2hfill"></div></div>
      </div>
    </div>
  </div>

  <canvas id="gc"></canvas>
  <div id="waveAnn">WAVE 1</div>

  <!-- Game Over -->
  <div id="gameOver">
    <div class="go-title">MISSION FAILED</div>
    <div class="go-stats">
      SCORE: <span id="goScore">0</span><br>
      WAVE: <span id="goWave">1</span><br>
      撃破数: <span id="goKills">0</span>
    </div>
    <button class="btn" onclick="backToTitle()">タイトルへ</button>
  </div>
</div>

<!-- Firebase -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, off, push, remove, serverTimestamp, onDisconnect }
  from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDEqOR4AqAQMbQS2yB6S1GBj0f1BMlXtvU",
  authDomain: "nazo-game.firebaseapp.com",
  projectId: "nazo-game",
  storageBucket: "nazo-game.firebasestorage.app",
  messagingSenderId: "743367689885",
  appId: "1:743367689885:web:dd356e956afc7e0922b674",
  databaseURL: "https://nazo-game-default-rtdb.asia-southeast1.firebasedatabase.app"
};

const fireApp = initializeApp(firebaseConfig);
const db = getDatabase(fireApp);

// ===== Canvas =====
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
resize(); window.addEventListener('resize', resize);

// ===== Game State =====
let myRole = null; // 'host' or 'guest'
let roomId = null;
let myName = '';
let partnerName = '';
let gameRunning = false;
let score = 0, kills = 0, wave = 1;
let betweenWaves = false;
let pingMs = 0;
let lastPingSent = 0;

const keys = {};
const mouse = { x: 400, y: 300, down: false };
window.addEventListener('keydown', e => { keys[e.key]=true; if(e.key===' ')e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key]=false; });
canvas.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; });
canvas.addEventListener('mousedown', () => mouse.down=true);
canvas.addEventListener('mouseup', () => mouse.down=false);

// ===== Screen helpers =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  document.getElementById(id).classList.remove('hidden');
}
window.showTitle = () => showScreen('screenTitle');
window.showCreate = async () => {
  myName = document.getElementById('nameInput').value.trim() || 'PILOT';
  const code = Math.random().toString(36).substring(2,6).toUpperCase();
  roomId = code;
  myRole = 'host';
  document.getElementById('lobbyCode').textContent = code;
  document.getElementById('slot1name').textContent = myName;
  document.getElementById('slot2dot').classList.remove('active');
  document.getElementById('slot2name').textContent = '待機中...';
  document.getElementById('startBtn').classList.add('disabled');
  document.getElementById('lobbyStatus').textContent = 'プレイヤー2を待っています...';
  showScreen('screenLobby');

  // Write room to Firebase
  await set(ref(db, `rooms/${code}`), {
    status: 'waiting',
    host: myName,
    guest: null,
    wave: 1,
    score: 0,
    created: serverTimestamp()
  });
  onDisconnect(ref(db, `rooms/${code}`)).remove();

  // Watch for guest
  onValue(ref(db, `rooms/${code}/guest`), snap => {
    const g = snap.val();
    if(g) {
      partnerName = g;
      document.getElementById('slot2dot').classList.add('active');
      document.getElementById('slot2name').textContent = g;
      document.getElementById('startBtn').classList.remove('disabled');
      document.getElementById('lobbyStatus').textContent = 'プレイヤー2が参加しました！';
      document.getElementById('lobbyStatus').className = 'status-msg ok';
    }
  });

  // Watch for game start signal
  onValue(ref(db, `rooms/${code}/status`), snap => {
    if(snap.val()==='playing' && myRole==='host') startGameLocal();
  });
};

window.showJoin = () => {
  myName = document.getElementById('nameInput').value.trim() || 'WINGMAN';
  showScreen('screenJoin');
};

window.joinRoom = async () => {
  const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
  if(code.length!==4){ document.getElementById('joinStatus').textContent='4文字のコードを入力してください'; document.getElementById('joinStatus').className='status-msg err'; return; }
  document.getElementById('joinStatus').textContent='接続中...'; document.getElementById('joinStatus').className='status-msg wait';
  const snap = await get(ref(db, `rooms/${code}`));
  if(!snap.exists()){ document.getElementById('joinStatus').textContent='ルームが見つかりません'; document.getElementById('joinStatus').className='status-msg err'; return; }
  const room = snap.val();
  if(room.status!=='waiting'){ document.getElementById('joinStatus').textContent='このルームはすでに開始済みです'; document.getElementById('joinStatus').className='status-msg err'; return; }

  roomId = code;
  myRole = 'guest';
  partnerName = room.host;
  await update(ref(db, `rooms/${code}`), { guest: myName });
  onDisconnect(ref(db, `rooms/${code}/guest`)).remove();

  document.getElementById('joinStatus').textContent='参加しました！ホストの開始を待っています...'; document.getElementById('joinStatus').className='status-msg ok';

  // Wait for start signal
  onValue(ref(db, `rooms/${code}/status`), snap => {
    if(snap.val()==='playing') startGameLocal();
  });
};

window.hostStartGame = async () => {
  if(myRole!=='host') return;
  await update(ref(db, `rooms/${roomId}`), { status:'playing' });
};

// ===== Game Entities =====
class Particle {
  constructor(x,y,vx,vy,color,life,size=2){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.life=life;this.maxLife=life;this.size=size;}
  update(){this.x+=this.vx;this.y+=this.vy;this.vx*=0.93;this.vy*=0.93;this.life--;return this.life>0;}
  draw(){const a=this.life/this.maxLife;ctx.globalAlpha=a*0.8;ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.x,this.y,this.size*a,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;}
}

class Bullet {
  constructor(x,y,angle,speed,owner,color,dmg){
    this.x=x;this.y=y;this.vx=Math.cos(angle)*speed;this.vy=Math.sin(angle)*speed;
    this.owner=owner;this.color=color;this.dmg=dmg;this.alive=true;this.trail=[];
    this.id=Math.random().toString(36).substr(2,8);
  }
  update(){
    this.trail.push({x:this.x,y:this.y});if(this.trail.length>7)this.trail.shift();
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0||this.x>canvas.width||this.y<0||this.y>canvas.height)this.alive=false;
  }
  draw(){
    for(let i=0;i<this.trail.length;i++){
      ctx.globalAlpha=(i/this.trail.length)*0.4;ctx.fillStyle=this.color;
      ctx.beginPath();ctx.arc(this.trail[i].x,this.trail[i].y,2,0,Math.PI*2);ctx.fill();
    }
    ctx.globalAlpha=1;ctx.fillStyle='#fff';
    ctx.shadowBlur=12;ctx.shadowColor=this.color;
    ctx.beginPath();ctx.arc(this.x,this.y,3,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;
  }
}

class Player {
  constructor(x,y,color,isMe){
    this.x=x;this.y=y;this.color=color;this.isMe=isMe;
    this.radius=14;this.hp=100;this.maxHp=100;this.speed=3.5;
    this.angle=0;this.shootCD=0;this.invincible=0;this.thrustT=0;
    this.alive=true;
  }
  update(bullets){
    this.shootCD=Math.max(0,this.shootCD-1);
    this.invincible=Math.max(0,this.invincible-1);
    this.thrustT++;
    if(!this.isMe)return;
    let dx=0,dy=0;
    if(keys['w']||keys['ArrowUp'])dy-=1;
    if(keys['s']||keys['ArrowDown'])dy+=1;
    if(keys['a']||keys['ArrowLeft'])dx-=1;
    if(keys['d']||keys['ArrowRight'])dx+=1;
    const l=Math.sqrt(dx*dx+dy*dy);if(l>0){dx/=l;dy/=l;}
    this.x=Math.max(this.radius,Math.min(canvas.width-this.radius,this.x+dx*this.speed));
    this.y=Math.max(this.radius+48,Math.min(canvas.height-this.radius,this.y+dy*this.speed));
    this.angle=Math.atan2(mouse.y-this.y,mouse.x-this.x);
    if((mouse.down||keys[' '])&&this.shootCD<=0){
      bullets.push(new Bullet(this.x,this.y,this.angle,9,'player',this.color,10));
      this.shootCD=10;
    }
  }
  draw(){
    if(!this.alive)return;
    ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);
    if(this.invincible%4<2){ctx.shadowBlur=0;}else{ctx.shadowBlur=20;ctx.shadowColor=this.color;}
    ctx.fillStyle=this.color;ctx.strokeStyle='rgba(255,255,255,0.6)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(18,0);ctx.lineTo(-10,-10);ctx.lineTo(-6,0);ctx.lineTo(-10,10);ctx.closePath();
    ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();
    ctx.shadowBlur=0;ctx.restore();
    if(this.thrustT%3===0){
      G.particles.push(new Particle(
        this.x+Math.cos(this.angle+Math.PI)*12,this.y+Math.sin(this.angle+Math.PI)*12,
        (Math.random()-0.5)*2+Math.cos(this.angle+Math.PI)*3,(Math.random()-0.5)*2+Math.sin(this.angle+Math.PI)*3,
        this.color,15,3));
    }
    // HP bar
    const bw=30;ctx.fillStyle='rgba(255,255,255,0.1)';ctx.fillRect(this.x-bw/2,this.y-24,bw,3);
    ctx.fillStyle=this.color;ctx.fillRect(this.x-bw/2,this.y-24,bw*(this.hp/this.maxHp),3);
    // Name
    ctx.fillStyle='rgba(255,255,255,0.5)';ctx.font='9px Share Tech Mono';ctx.textAlign='center';
    ctx.fillText(this.isMe?myName:partnerName,this.x,this.y-28);
  }
  takeDamage(dmg){
    if(this.invincible>0)return;
    this.hp=Math.max(0,this.hp-dmg);this.invincible=45;
    for(let i=0;i<8;i++){const a=Math.random()*Math.PI*2;G.particles.push(new Particle(this.x,this.y,Math.cos(a)*4,Math.sin(a)*4,this.color,20,3));}
    if(this.hp<=0)this.alive=false;
  }
}

class Enemy {
  constructor(x,y,type){
    this.x=x;this.y=y;this.type=type;this.angle=0;this.alive=true;this.shootTimer=0;
    this.id=Math.random().toString(36).substr(2,8);
    if(type==='basic'){this.r=12;this.hp=30;this.maxHp=30;this.speed=1.5;this.color='#ff6600';this.pts=100;this.dmg=15;this.sr=0;}
    else if(type==='fast'){this.r=8;this.hp=15;this.maxHp=15;this.speed=3;this.color='#ffaa00';this.pts=150;this.dmg=10;this.sr=0;}
    else if(type==='shooter'){this.r=14;this.hp=50;this.maxHp=50;this.speed=1;this.color='#cc00ff';this.pts=200;this.dmg=20;this.sr=80;}
    else if(type==='tank'){this.r=20;this.hp=120;this.maxHp=120;this.speed=0.7;this.color='#ff0044';this.pts=400;this.dmg=30;this.sr=0;}
  }
  update(players,bullets){
    let nearest=null,minD=Infinity;
    for(const p of players){if(!p.alive)continue;const d=Math.hypot(p.x-this.x,p.y-this.y);if(d<minD){minD=d;nearest=p;}}
    if(!nearest)return;
    const dx=nearest.x-this.x,dy=nearest.y-this.y,d=Math.hypot(dx,dy);
    if(d>0){this.x+=dx/d*this.speed;this.y+=dy/d*this.speed;}
    this.angle=Math.atan2(dy,dx);
    if(this.sr>0){this.shootTimer++;if(this.shootTimer>=this.sr){bullets.push(new Bullet(this.x,this.y,this.angle,4,'enemy',this.color,this.dmg));this.shootTimer=0;}}
    for(const p of players){if(!p.alive)continue;if(Math.hypot(p.x-this.x,p.y-this.y)<this.r+p.radius)p.takeDamage(this.dmg);}
  }
  draw(){
    ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);
    ctx.shadowBlur=15;ctx.shadowColor=this.color;ctx.fillStyle=this.color;
    if(this.type==='tank'){ctx.beginPath();for(let i=0;i<6;i++){const a=i/6*Math.PI*2;i===0?ctx.moveTo(Math.cos(a)*this.r,Math.sin(a)*this.r):ctx.lineTo(Math.cos(a)*this.r,Math.sin(a)*this.r);}ctx.closePath();ctx.fill();}
    else if(this.type==='shooter'){ctx.beginPath();ctx.moveTo(this.r,0);ctx.lineTo(0,this.r);ctx.lineTo(-this.r,0);ctx.lineTo(0,-this.r);ctx.closePath();ctx.fill();}
    else{ctx.beginPath();ctx.moveTo(this.r,0);ctx.lineTo(-this.r/2,-this.r*0.75);ctx.lineTo(-this.r/2,this.r*0.75);ctx.closePath();ctx.fill();}
    ctx.shadowBlur=0;ctx.restore();
    const bw=this.r*2.5;ctx.fillStyle='rgba(255,255,255,0.1)';ctx.fillRect(this.x-bw/2,this.y-this.r-8,bw,3);
    ctx.fillStyle=this.color;ctx.fillRect(this.x-bw/2,this.y-this.r-8,bw*(this.hp/this.maxHp),3);
  }
  takeDamage(dmg){
    this.hp-=dmg;if(this.hp<=0){this.alive=false;for(let i=0;i<16;i++){const a=Math.random()*Math.PI*2,s=Math.random()*5+2;G.particles.push(new Particle(this.x,this.y,Math.cos(a)*s,Math.sin(a)*s,this.color,30+Math.random()*20,Math.random()*4+1));}}
  }
}

// ===== Game Manager =====
const G = {
  me: null, partner: null,
  enemies: [], bullets: [], particles: [],
  myColor: null, partnerColor: null
};

function startGameLocal() {
  showScreen('__none__'); // hide all screens
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  document.getElementById('hud').style.display='flex';
  gameRunning=true; score=0; kills=0; wave=1; betweenWaves=false;

  const isHost = myRole==='host';
  G.myColor = isHost ? '#00f5ff' : '#ff0099';
  G.partnerColor = isHost ? '#ff0099' : '#00f5ff';

  const cx=canvas.width/2, cy=canvas.height/2;
  G.me = new Player(cx+(isHost?-80:80), cy, G.myColor, true);
  G.partner = new Player(cx+(isHost?80:-80), cy, G.partnerColor, false);
  G.enemies=[]; G.bullets=[]; G.particles=[];

  document.getElementById('p1label').textContent = myName;
  document.getElementById('p2label').textContent = partnerName;

  // Firebase sync listeners
  setupSync();

  if(isHost) spawnWave();

  requestAnimationFrame(gameLoop);
}

// ===== Firebase Sync =====
let syncInterval = null;
let bulletQueue = [];

function setupSync() {
  const base = `rooms/${roomId}`;

  // Listen to partner state
  const partnerKey = myRole==='host' ? 'guest_state' : 'host_state';
  onValue(ref(db, `${base}/${partnerKey}`), snap => {
    const d = snap.val();
    if(!d) return;
    G.partner.x = d.x; G.partner.y = d.y; G.partner.angle = d.a;
    G.partner.hp = d.hp; G.partner.alive = d.alive;
  });

  // Listen to partner bullets
  const partnerBulletKey = myRole==='host' ? 'guest_bullets' : 'host_bullets';
  onValue(ref(db, `${base}/${partnerBulletKey}`), snap => {
    const d = snap.val();
    if(!d) return;
    for(const id in d) {
      const bd = d[id];
      if(!G.bullets.find(b=>b.id===id)) {
        const b = new Bullet(bd.x,bd.y,bd.a,9,'partner',G.partnerColor,10);
        b.id=id; G.bullets.push(b);
      }
    }
  });

  // Host controls enemies
  if(myRole==='host') {
    // Sync enemies to Firebase periodically
  } else {
    // Guest listens to enemies
    onValue(ref(db, `${base}/enemies`), snap => {
      const d = snap.val();
      if(!d) return;
      // Sync enemy positions
      for(const e of G.enemies) {
        if(d[e.id]) { e.x=d[e.id].x; e.y=d[e.id].y; e.hp=d[e.id].hp; e.alive=d[e.id].alive; }
      }
      // Add new enemies
      for(const id in d) {
        if(!G.enemies.find(e=>e.id===id)) {
          const ed=d[id];
          const en=new Enemy(ed.x,ed.y,ed.type);
          en.id=id; en.hp=ed.hp; en.maxHp=ed.hp;
          G.enemies.push(en);
        }
      }
    });

    // Guest listens to wave/score
    onValue(ref(db, `${base}/score`), snap => { if(snap.val()!==null){score=snap.val();document.getElementById('scoreDisp').textContent=String(score).padStart(6,'0');}});
    onValue(ref(db, `${base}/wave`), snap => { if(snap.val()){wave=snap.val();document.getElementById('waveDisp').textContent=wave;}});
    onValue(ref(db, `${base}/waveSignal`), snap => { if(snap.val()){showWaveAnnounce(snap.val());}});
  }

  // Host listens to guest damage events
  if(myRole==='host') {
    onValue(ref(db, `${base}/enemy_hit`), snap => {
      const d=snap.val();if(!d)return;
      const e=G.enemies.find(en=>en.id===d.eid);
      if(e&&e.alive){e.takeDamage(d.dmg);score+=e.alive?0:(e.pts*wave);kills++;syncScore();}
    });
  }

  // Ping system
  const pingKey = myRole==='host'?'host_ping':'guest_ping';
  const pongKey = myRole==='host'?'guest_pong':'host_pong';
  setInterval(()=>{
    lastPingSent=Date.now();
    set(ref(db,`${base}/${pingKey}`),lastPingSent);
  },3000);
  onValue(ref(db,`${base}/${pongKey}`),snap=>{
    if(snap.val()) pingMs=Date.now()-snap.val();
  });
  // Respond to pings
  const oppPing = myRole==='host'?'guest_ping':'host_ping';
  const myPong = myRole==='host'?'host_pong':'guest_pong';
  onValue(ref(db,`${base}/${oppPing}`),snap=>{
    if(snap.val()) set(ref(db,`${base}/${myPong}`),snap.val());
  });

  // Sync my state every frame (throttled)
  syncInterval = setInterval(syncMyState, 50);

  // Game over listener
  onValue(ref(db,`${base}/gameover`),snap=>{
    if(snap.val()&&gameRunning) triggerGameOver();
  });

  // Disconnect cleanup
  onDisconnect(ref(db,`${base}/${myRole==='host'?'host_state':'guest_state'}`)).remove();
}

function syncMyState() {
  if(!gameRunning||!G.me) return;
  const key = myRole==='host'?'host_state':'guest_state';
  set(ref(db,`rooms/${roomId}/${key}`),{
    x:Math.round(G.me.x),y:Math.round(G.me.y),
    a:parseFloat(G.me.angle.toFixed(3)),
    hp:G.me.hp,alive:G.me.alive
  });
}

function syncMyBullet(b) {
  const key = myRole==='host'?'host_bullets':'guest_bullets';
  set(ref(db,`rooms/${roomId}/${key}/${b.id}`),{x:Math.round(b.x),y:Math.round(b.y),a:parseFloat(Math.atan2(b.vy,b.vx).toFixed(3))});
  // Auto-delete after 3s
  setTimeout(()=>{ remove(ref(db,`rooms/${roomId}/${key}/${b.id}`)); },3000);
}

function syncEnemies() {
  if(myRole!=='host') return;
  const data={};
  for(const e of G.enemies) data[e.id]={x:Math.round(e.x),y:Math.round(e.y),hp:e.hp,alive:e.alive,type:e.type};
  set(ref(db,`rooms/${roomId}/enemies`),data);
}

function syncScore() {
  if(myRole!=='host') return;
  update(ref(db,`rooms/${roomId}`),{score,wave});
}

function reportHit(enemyId, dmg) {
  // Guest reports hits to host
  if(myRole==='host') return; // host handles directly
  set(ref(db,`rooms/${roomId}/enemy_hit`),{eid:enemyId,dmg,t:Date.now()});
}

function spawnWave() {
  if(myRole!=='host') return;
  const types=['basic','fast','shooter','tank'];
  const count=5+wave*3;
  for(let i=0;i<count;i++){
    const r=Math.random();
    let t='basic';
    if(wave>=4&&r<0.15)t='tank';
    else if(wave>=2&&r<0.3)t='shooter';
    else if(r<0.5)t='fast';
    let x,y;
    const side=Math.floor(Math.random()*4);
    if(side===0){x=Math.random()*canvas.width;y=-30;}
    else if(side===1){x=canvas.width+30;y=Math.random()*canvas.height;}
    else if(side===2){x=Math.random()*canvas.width;y=canvas.height+30;}
    else{x=-30;y=Math.random()*canvas.height;}
    const e=new Enemy(x,y,t);
    G.enemies.push(e);
  }
  syncEnemies();
  update(ref(db,`rooms/${roomId}`),{wave,score,waveSignal:wave});
  showWaveAnnounce(wave);
}

function showWaveAnnounce(w) {
  const el=document.getElementById('waveAnn');
  el.textContent=`WAVE ${w}`;el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'),2000);
  document.getElementById('waveDisp').textContent=w;
}

// ===== Game Loop =====
let prevBulletCount=0;
function gameLoop(ts) {
  if(!gameRunning) return;
  ctx.fillStyle='#020814';ctx.fillRect(0,0,canvas.width,canvas.height);

  const players=[G.me,G.partner].filter(p=>p&&p.alive);

  // My player update
  const prevBullets=[...G.bullets];
  G.me.update(G.bullets);
  // Detect new bullets I fired
  for(const b of G.bullets) {
    if(!prevBullets.includes(b)&&b.owner==='player') syncMyBullet(b);
  }

  // Enemies (only host simulates, guest syncs)
  if(myRole==='host') {
    for(const e of G.enemies) e.update(players,G.bullets);
    G.enemies=G.enemies.filter(e=>e.alive);
  } else {
    // Guest only renders enemies (positions come from Firebase)
    for(const e of G.enemies) {
      // Still do local collision/shooting for responsiveness
      for(const p of players){if(!p.alive)continue;if(Math.hypot(p.x-e.x,p.y-e.y)<e.r+p.radius)p.takeDamage(e.dmg);}
    }
    G.enemies=G.enemies.filter(e=>e.alive);
  }

  // Bullet collisions
  for(const b of G.bullets) {
    if(!b.alive)continue;
    b.update();
    if(b.owner==='enemy') {
      for(const p of [G.me]){
        if(!p.alive)continue;
        if(Math.hypot(p.x-b.x,p.y-b.y)<p.radius){p.takeDamage(b.dmg);b.alive=false;break;}
      }
    } else if(b.owner==='player'||b.owner==='partner') {
      for(const e of G.enemies){
        if(!e.alive)continue;
        if(Math.hypot(e.x-b.x,e.y-b.y)<e.r){
          b.alive=false;
          if(myRole==='host'){e.takeDamage(b.dmg);if(!e.alive){score+=e.pts*wave;kills++;syncScore();}}
          else reportHit(e.id,b.dmg);
          for(let i=0;i<5;i++){const a=Math.random()*Math.PI*2;G.particles.push(new Particle(b.x,b.y,Math.cos(a)*3,Math.sin(a)*3,'#fff',10,2));}
          break;
        }
      }
    }
  }
  G.bullets=G.bullets.filter(b=>b.alive);

  // Particles
  G.particles=G.particles.filter(p=>p.update());

  // Draw
  for(const p of G.particles)p.draw();
  for(const b of G.bullets)b.draw();
  for(const e of G.enemies)e.draw();
  if(G.partner)G.partner.draw();
  G.me.draw();

  // Crosshair
  ctx.strokeStyle='rgba(0,245,255,0.7)';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(mouse.x-12,mouse.y);ctx.lineTo(mouse.x+12,mouse.y);ctx.moveTo(mouse.x,mouse.y-12);ctx.lineTo(mouse.x,mouse.y+12);ctx.stroke();
  ctx.strokeRect(mouse.x-5,mouse.y-5,10,10);

  // Sync enemies periodically (host)
  if(myRole==='host'&&G.enemies.length>0) syncEnemies();

  // Update HUD
  const me=G.me,pt=G.partner;
  document.getElementById('p1hfill').style.width=Math.max(0,me.hp)/me.maxHp*100+'%';
  document.getElementById('p1hnum').textContent=Math.max(0,Math.round(me.hp));
  if(pt){document.getElementById('p2hfill').style.width=Math.max(0,pt.hp)/pt.maxHp*100+'%';document.getElementById('p2hnum').textContent=Math.max(0,Math.round(pt.hp));}
  document.getElementById('scoreDisp').textContent=String(score).padStart(6,'0');
  document.getElementById('pingVal').textContent=pingMs||'--';
  const pd=document.getElementById('pingDot');
  pd.style.background=pingMs<100?'#00ff88':pingMs<200?'#ffee00':'#ff0044';
  pd.style.boxShadow=`0 0 6px ${pd.style.background}`;

  // Wave clear (host)
  if(myRole==='host'&&G.enemies.length===0&&!betweenWaves){
    betweenWaves=true;
    setTimeout(()=>{
      wave++;betweenWaves=false;
      G.me.hp=Math.min(G.me.maxHp,G.me.hp+20);
      spawnWave();
    },2800);
  }

  // Game over check
  const bothDead=!G.me.alive&&(!G.partner||!G.partner.alive);
  if(bothDead||(!G.me.alive&&(!G.partner||!G.partner.alive))){
    gameRunning=false;
    if(myRole==='host') set(ref(db,`rooms/${roomId}/gameover`),true);
    triggerGameOver(); return;
  }

  requestAnimationFrame(gameLoop);
}

function triggerGameOver(){
  gameRunning=false;
  if(syncInterval)clearInterval(syncInterval);
  document.getElementById('hud').style.display='none';
  document.getElementById('goScore').textContent=String(score).padStart(6,'0');
  document.getElementById('goWave').textContent=wave;
  document.getElementById('goKills').textContent=kills;
  document.getElementById('gameOver').classList.add('show');
}

window.backToTitle = async () => {
  document.getElementById('gameOver').classList.remove('show');
  document.getElementById('hud').style.display='none';
  if(roomId) await remove(ref(db,`rooms/${roomId}`));
  roomId=null;myRole=null;G.enemies=[];G.bullets=[];G.particles=[];
  showScreen('screenTitle');
};

// Expose to window
window.hostStartGame = async () => {
  if(myRole!=='host') return;
  await update(ref(db, `rooms/${roomId}`), { status:'playing' });
};
</script>
</body>
</html>
